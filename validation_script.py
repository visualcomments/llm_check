import json
import subprocess
import sys
import os
import time
import re
from typing import Dict, List, Any
from datetime import datetime

def ensure_output_folder(folder_name: str = "validation_output") -> str:
    """Ensures the output folder exists."""
    path = os.path.join("/kaggle/working/", folder_name)
    os.makedirs(path, exist_ok=True)
    return path

def validate_model_code(code: str, model_name: str, validation_folder: str, timeout: int = 40) -> Dict[str, Any]:
    """
    Validates the code by saving it to a temp file and running it.
    Assumes the code has a 'if __name__ == "__main__":' block with unittests.
    """
    # Create a unique-ish temp file for the harness
    tmp_file = os.path.join(validation_folder, f"temp_validate_{re.sub(r'[^A-Za-z0-9_]+', '_', model_name)}_{int(time.time())}.py")
    
    with open(tmp_file, 'w', encoding='utf-8') as f:
        f.write(code)

    result = {
        "model": model_name,
        "overall_success": False,
        "error_log": None
    }

    try:
        proc = subprocess.run(
            [sys.executable, tmp_file], 
            capture_output=True, 
            text=True, 
            encoding='utf-8', 
            errors='replace',
            timeout=timeout
        )
        
        if proc.returncode == 0:
            # Success! The script ran and exited cleanly (tests passed).
            result["overall_success"] = True
            result["error_log"] = proc.stdout # Store stdout for any potential test output
        else:
            # Failure. The script failed (test failures or other runtime error).
            result["overall_success"] = False
            result["error_log"] = proc.stderr or proc.stdout
            
    except subprocess.TimeoutExpired:
        result["overall_success"] = False
        result["error_log"] = "Execution timed out."
    except Exception as e:
        result["overall_success"] = False
        result["error_log"] = f"Validation harness failed: {str(e)}"
    finally:
        # Clean up the temp file
        if os.path.exists(tmp_file):
            os.remove(tmp_file)

    return result

def main():
    results_dir = "/kaggle/working/run_results"
    final_results_file = os.path.join(results_dir, "final_results.json")
    output_filename = "comprehensive_validation.json"
    
    validation_folder = ensure_output_folder()
    output_file = os.path.join(validation_folder, output_filename)
    
    if not os.path.exists(final_results_file):
        print(f"Error: The results file was not found at '{final_results_file}'")
        print("Please run the CallLLM script first to generate the results.")
        return

    print(f"Loading results from {final_results_file}...")
    with open(final_results_file, 'r', encoding='utf-8') as f:
        data = json.load(f)

    # Get the task text used, if available (for logging)
    # This requires CallLLM.py to be modified to save it, which it doesn't.
    # We'll just add a generic description.
    task_description = "Generic validation by executing the script's unittests."

    all_validation_results = {
        "validation_timestamp": datetime.now().isoformat(),
        "source_file": final_results_file,
        "validation_task": task_description,
        "models": []
    }

    results = data.get('results', [])
    print(f"Starting validation for {len(results)} models...")

    for i, result in enumerate(results, 1):
        model_name = result.get('model', f'Unknown_{i}')
        final_code = result.get('final_code')
        
        print(f"\r({i}/{len(results)}) Validating model: {model_name.ljust(40)}", end="", flush=True)
        
        if not final_code or not final_code.strip():
            model_validation = {
                "model": model_name,
                "overall_success": False,
                "error_log": "No final_code was generated by the model."
            }
        else:
            model_validation = validate_model_code(final_code, model_name, validation_folder)
        
        all_validation_results["models"].append(model_validation)

    print(f"\nValidation complete. Saving detailed report to {output_file}...")
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(all_validation_results, f, ensure_ascii=False, indent=4)
        
    print(f"Validation report saved to {output_file}")

if __name__ == "__main__":
    main()