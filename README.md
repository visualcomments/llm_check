
# LLM Sorting (Neighbor Transpositions) — Evaluation Harness


## Быстрый старт

```bash
pip install -r requirements.txt
python CallLLM.py --max_workers 8            # запустить генерацию кода по множеству моделей (g4f)
python validation_script.py                  # прогнать валидацию
python analysis_script.py                    # собрать аналитический отчёт
```

### Локальная модель Hugging Face

Если у вас есть локально установленная модель (например, LLM для кода), можно протестировать **только её**:

```bash
python CallLLM.py --hf_model /path/to/local/model
```

Требуется доступность `transformers` (+ `torch`, `accelerate`, `safetensors` по ситуации) и достаточные ресурсы.  
Если `transformers/torch` недоступны — скрипт просто пропустит локальный запуск и выведет предупреждение.

## Точное задание (вшито в промпт)

Модуль должен **обязательно** определять функцию:

```python
def neighbor_sort_moves(vec: list) -> list:
    """
    Возвращает список мувов (i, j), где j == (i+1) mod n,
    применение которых к исходному вектору приводит к неубыванию элементов.
    Вход не мутируется; допустимы дубликаты.
    """
```

- Индексы — **0-базированные**. Цикличность: пара `(n-1, 0)` также допустима.
- Любой корректный алгоритм (например, «кольцевой» bubble sort) подойдёт, если **каждый** мув — соседняя транспозиция.
- Нельзя использовать `input()`, файлы или сеть. Модуль должен быть **импортируемым**.

## Как проходит валидация

1. Мы импортируем модуль, **глушим сторонние принты**, находим `neighbor_sort_moves(vec)`.
2. Генерируем наборы векторов (реверс, две случайные перестановки, вариант с дубликатами).
3. Запускаем функцию, получаем `moves`.
4. Проверяем, что каждый мув соответствует соседней транспозиции на кольце; применяем их и сравниваем с `sorted(vec)`.

Если для всех векторов фиксированной длины `n` проверка проходит — длина считается «пройденной».  
Модель «успешна» целиком, если прошла **все** `n`.

## Структура репозитория

```
CallLLM.py            # оркестратор генерации кода (g4f и/или локальная HF)
validation_script.py  # надёжная проверка корректности мувов
analysis_script.py    # агрегация и отчёты
requirements.txt
tests/
  test_apply_moves_smoke.py  # мини-проверки логики применений мувов
```

## Требования

- Python 3.10+
- Для g4f-провайдеров — интернет.
- Для локальных моделей — установленный `transformers` (+ `torch`) и сама модель.

## Лицензия

MIT
